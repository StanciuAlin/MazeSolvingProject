# Maze Solving Project - Knowledge Representation and Problem Solving

Maze solving project implements and compares various state-space search algorithms to solve mazes. The primary goal is to analyze and compare the performance of different search strategies based on node expansion, solution depth, execution time, and optimality.

## üìÇ Project Structure

The project follows a modular architecture to ensure extensibility and clean code:

- **`main.py`**: The entry point of the application. It handles loading the maze, executing experiments, and displaying result tables.
- **`maze_engine.py`**: Contains the `Maze` class, which manages the grid and movement validation.
- **`algorithms/`**: A dedicated package for search strategies:
  - `base.py`: Defines the abstract `SearchAlgorithm` class and the `Node` structure.
  - `bfs.py`: Implementation of Breadth-First Search.
  - `dfs.py`: Implementation of Depth-First Search.
  - `astar.py`: Implementation of A\* Search using Manhattan distance.
  - `greedy.py`: Implementation of Greedy Best-First Search.
- **`utils/`**: Utility modules for the project:
  - `analyzer.py`: Collects metrics and generates comparative graphs.
  - `input_handler.py`: Handles file loading and graphical visualization of the maze.
- **`inputs/`**: Directory containing maze definition files (e.g., `complex.txt`, `simple.txt`, `trap.txt`).

## üß† Heuristics in A\* Search

The A\* algorithm uses a cost function `f(n) = g(n) + h(n)`, where `g(n)` is the actual cost from the start to the current node, and `h(n)` is the **heuristic** estimate to the goal.

### Manhattan Distance

For this project, we utilize the **Manhattan Distance** (also known as $L_1$ distance or Taxicab geometry) as the primary heuristic. It is calculated as the sum of the absolute differences of their Cartesian coordinates:

$$h(n) = |x_{current} - x_{goal}| + |y_{current} - y_{goal}|$$

**Why Manhattan Distance?**

1. **Admissibility**: In a grid where movement is restricted to four directions (up, down, left, right), the Manhattan distance never overestimates the actual cost to the goal. This ensures that A\* always finds the optimal (shortest) path.
2. **Efficiency**: It is computationally inexpensive to calculate, providing a significant performance boost over uninformed searches like BFS in complex mazes.
3. **Informed Guidance**: Unlike Euclidean distance (straight-line), Manhattan distance better reflects the "grid-based" nature of the maze, guiding the search more effectively toward the target.

## üõ†Ô∏è Installation & Setup

1. **Prerequisites**: Ensure you have Python installed on your system.
2. **Install Dependencies**: Use the provided `requirements.txt` to install the necessary libraries (`numpy` and `matplotlib`):
   ```
   pip install -r requirements.txt
   ```

## Usage

To run the project and view the algorithm comparisons:

1. Open main.py.
2. (Optional) Change the filename variable to test a different maze from the inputs/ folder.
3. Run the script:

```
python main.py
```

## Performance Analysis

For each algorithm, the program analyzes and compares:

- **Number of Expanded Nodes**: Indicates the search efficiency.
- **Solution Depth**: The number of steps in the final path.
- **Execution Time**: The time taken to find the solution.
- **Optimality**: Whether the algorithm guarantees the shortest possible path.

The results are presented through **comparative tables** and **graphical plots** generated by `matplotlib`.

## Input Format

Mazes are defined in `.txt` files using the following convention:

- `.` (dot) represents a free path (0 in the grid).
- `#` (hash) represents a wall or obstacle (1 in the grid).
